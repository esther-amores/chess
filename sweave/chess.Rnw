%\documentclass[notitlepage]{article}
\documentclass[10pt,a4paper,twoside]{article}

\usepackage[utf8]{inputenc}
\usepackage[catalan]{babel}
\usepackage[nottoc,numbib]{tocbibind}      % for bibliography in the table of contents
\usepackage{hyperref}                      % link to website: \url{}.
\usepackage[hang,footnotesize,bf]{caption} % customized caption
\usepackage{authblk}                       % customized author and affiliation
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[left=2.5cm,top=3cm,bottom=3cm,right=2.5cm]{geometry}   % text margins
\usepackage{booktabs}                      % for booktabs in print(xtable) 
\usepackage{unitsdef}                      % for typesetting units
\usepackage{fancyhdr}                      % customized headers/footers
\usepackage{enumitem}                      % customized enumerate lists
\usepackage{cancel}                        % for cancelling a term
\usepackage{bbm}
\usepackage{xcolor, colortbl}
\usepackage{mathtools}

\hypersetup{
    colorlinks,
    linkcolor={black!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}

\newcommand{\R}{\textsf{R }}
\newcommand{\Rpackage}[1]{\textsf{#1}}
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\newcommand{\I}{\mathbbm{1}}
%\newcommand\allbold[1]{{\boldmath\textbf{#1}}}
\newcommand{\pvalue}{$p$-value }


\def\Item#1\\{\item\allbold{#1}\\}          % set items of an enumerate or itemize list in bold 
\let\origappendix\appendix                 % save the existing appendix command
\renewcommand\appendix{\clearpage\pagenumbering{roman}\origappendix} % change format of appendix's number of page

\definecolor{lightblue}{rgb}{0.68, 0.85, 0.9}

<<include=FALSE>>=
library(knitr)
opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  fig.align = "center"
)
@


%%%%%%%%%%%%%%%
%%%
%%% Header and footer
%%%
%%%%%%%%%%%%%%%
\pagestyle{fancy}
\fancyhf{}
\setlength\headheight{15pt}
\fancyhead[L]{Modelització de Dades Complexes}
\fancyhead[R]{PAC 1}
\fancyfoot[R]{\thepage}


%%%%%%%%%%%%%%%
%%%
%%% Title page
%%%
%%%%%%%%%%%%%%%
\begin{document}
\SweaveOpts{concordance=TRUE}

\title{\normalsize \textsc{Modelització de Dades Complexes}
		\\ [2.0cm]
		\HRule{0.5pt} \\
		\LARGE \textbf{\uppercase{Anàlisi d'una Xarxa Bayesiana}\\ Final d'una partida d'escacs: rei-torre vs. rei-peó en a7}
		\HRule{2pt} \\ [0.5cm]
		\normalsize \today \vspace*{5\baselineskip}}

\date{}

\author[1]{Esther Amores Gago}
\author[2]{Anna Costa Garrido}
\author[3]{Oscar Ortiz Romero}

\affil[1]{Applied Statistics Student -- Universitat Autònoma de Barcelona}

\maketitle
\thispagestyle{empty}

\newpage


%%%%%%%%%%%%%%%
%%%
%%% Table of contents
%%%
%%%%%%%%%%%%%%%
\clearpage
\tableofcontents
\clearpage


%%%%%%%%%%%%%%%
%%%
%%% Packages
%%%
%%%%%%%%%%%%%%%

<<packages, warning=FALSE, message=FALSE, echo=FALSE>>=
library(bnlearn)
library(gRain)
library(rchess)
library(Rgraphviz)
library(tidyverse)
library(MASS) # per realitzar el stepwise
library(readr)
library(xtable)

# OSCAR I ANNA: EXECUTEU AQUEST CODI PER A QUE NO US DONI PROBLEMES COMPILAR EL .Rnw
# devtools::install_github("jbkunst/rchess")
# webshot::install_phantomjs()
@


%%%%%%%%%%%%%%%
%%%
%%% Section: Introducció
%%%
%%%%%%%%%%%%%%%
\section{Introducció}
\label{sec:intro}


%%%%%%%%%%%%%%%
%%%
%%% Subection: Els escacs
%%%
%%%%%%%%%%%%%%%
\subsection{Els escacs}
Els escacs són un dels jocs de taula més antics i populars, jugat per dos oponents que mouen 16 peces segons unes determinades regles fixes a través d'un tauler d'escacs i intenta fer escac i mat al rei de l'oponent \cite{chess}. Cada jugador té les peces d'un color, que pot ser blanc o negre, i disposa en iniciar la partida de totes les peces d'un d'aquests colors, que són un rei, una reina (o dama), dos alfils, dos cavalls, dues torres i vuit peons disposades tal i com mostra la Figura \ref{fig:chss}.

\begin{figure}[h]
     \begin{center}
<<>>=
chss <- Chess$new()
plot(chss)
@
     \caption{Diagrama d'escacs. Tauler d'escacs amb les peces col·locades inicialment}
     \label{fig:chss}
     \end{center}
\end{figure}


Tradicionalment es considera que si el valor d'un peó com a unitat comparativa és d'un punt, cada alfil i cada cavall en valen tres, cada torre cinc i la reina deu. Inicia la partida el jugador que té les peces blanques, i els dos jugadors van movent alternativament les pròpies peces, una cada vegada, intentant de matar el nombre més gran possible de les del contrari o bé d’aconseguir una posició dominant i que el rei d’aquest resti indefens. Si no pot fer escac i mat cap dels jugadors, la partida acaba en taules \cite{enciclopedia}.

En una partida d'escacs existeixen tres fases: l'obertura, on els jugadors despleguen les seves peces en posicions útils per al joc; el joc mitjà, on les peces ja estan desplegades, es lluita per cada casella i els jugadors fan plans d'atac i de defensa; i el final, on la majoria de les peces estan fóra el tauler, els reis adopten un paper més actiu en la lluita i la promoció (o coronació) d'un peó és un factor decisiu \cite{fases}.

Així doncs, la partida finalitza quan un dels jugadors fa escac i mat i guanya, o bé quan els jugadors empaten (fan taules). Els finals en escacs es classifiquen d'acord amb el tipus de peces i la quantitat de peces que queden al tauler \cite{final}. 

Per entendre les variables de la base de dades, cal tenir en compte els elements bàsics del tauler d'escacs \cite{escacs}:
\begin{description}
    \item[Fila] Cadascuna de les vuit línies de vuit caselles que es numeren de l'1 al 8, començant des de la primera fila pel que fa al bàndol de les peces blanques.
    \item[Columna] Cadascuna de les vuit línies de vuit caselles que s'anomenen amb lletres minúscules de la (a) a la (h), començant des de la primera columna esquerra pel que fa al bàndol de les peces blanques.
    \item[Diagonal] Cadascuna de les 16 línies que es formen agrupant les caselles diagonalment. Les dues grans diagonals (a1-h8 o bé h1-a8) tenen vuit caselles.
    \item[Centre] El centre del tauler són les quatre caselles centrals.
    \item[Cantonades] Cadascuna de les quatre caselles situades a les cantonades del tauler.
    \item[Vores] Les dues columnes (a i h) i dues files (1 i 8) situades als extrems del tauler.
\end{description}


%%%%%%%%%%%%%%%
%%%
%%% Subection: Base de dades
%%%
%%%%%%%%%%%%%%%
\subsection{Base de dades}
En aquest treball s'utilitza una base de dades de l'any 1989 que té un total de 3196 registres i 36 variables, no té cap valor perdut (\textit{missing}), i ha estat extreta del portal \textit{UCI Machine Learning Repository} \cite{database}. Les dades van ser originalment generades i descrites per Alen Shapiro, i el format del dataset va ser modificat el 1990 per tal que coincidís amb el format de la resta de bases de dades del repositori UCI.

Per tant, cadascun d'aquests registres representa, de les 3196 posicions de partides registrades, un tipus de final concret: torre i rei contra rei i peó. En aquest cas, torre i rei negres contra rei i peó blancs, on el peó blanc està en la posició del tauler a7 (veure Figura \ref{fig:chss2}). És el torn de les blanques.Totes les variables prenen 2 valors, que són vertader (TRUE) o fals (FALSE), a excepció de les variables \textbf{dwipd} que pren els valors ``g'' o ``l'', \textbf{katri} que pren els valors ``b'', ``n'' i ``w'' (és la única variable que pren 3 valors) i \textbf{target}, que pren els valors ``win'' i ``nowin''.

\begin{figure}[ht!]
     \begin{center}
<<>>=
# https://www.apronus.com/chess/diagram/editor/
chss2 <- Chess$new("8/P7/8/1k6/5r2/8/K7/8 w - - 0 1")
plot(chss2)
@
     \caption{Diagrama d'escacs. Torre i rei negres contra rei i peó blancs.}
     \label{fig:chss2}
     \end{center}
\end{figure}


A continuació s'hi troben de manera detallada cadascuna de les variables de la base de dades, explicades a partir d'un expemple (veure Figura \ref{fig:chss2}):

\begin{description}
    \item[bkblk]el rei negre no està en el camí de les peces blanques
    \item[bknwy]el rei no molesta en cap moviment de la torre negra (black rook)
    \item[bkon8]el rei negre està a la fila 8 per ajudar a la torre negra
    \item[bkona]el rei negre està a la columna A per ajudar a la torre negra
    \item[bkspr]el rei negre pot ajudar a la torre negre amb 1 moviment
    \item[bkxbq]el rei negre no està atacat de cap manera pel peó coronat
    \item[bkxcr]el rei negre pot atacar la cuadrícula crítica al voltant de b7 
    \item[bkxwp]el rei negre pot atacar el peó blanc
    \item[blxwp]negres ataquen al peó blanc (torre negre només pot en direcció x=-1, és a dir, cap a f7)
    \item[bxqsq]una o més peces negres (és a dir, o el rei o la torre) controlen el quadrat de la coronació
    \item[cntxt]el rei blanc està a una cantonada i no en a8
    \item[dsopp]els reis es troben en oposició: es troben cara a cara en una fila o columna, amb només una casella entre ells
    \item[dwipd]la distància del rei blanc al punt d'intersecció f4 és gran (\textit{great}, g) o petita (\textit{low}, l)
    \item[hdchk]es fa escac a la descoberta, és a dir, és l'escac que fa una peça en moure's una altra peça del mateix bàndol que n'obstaculitzava l'acció.
    \item[katri]el rei negre controla el punt d'intersecció de blanques (\textit{white}, w), negres (\textit{black}, b) o cap (\textit{none}, n)
    \item[mulch]les peces negres poden tornar a fer escac per guanyar avantatge
    \item[qxmsq]la casella d'escac i mat és atacada d'alguna manera pel peó blanc coronat
    \item[r2ar8]la torre negra no té accés a la fila 8 o a la columna A
    \item[reskd]el rei blanc pot ser atacat doblement  
    \item[reskr]la torre negra en a4 faria una amenaça doble
    \item[rimmx]la torre negra pot ser capturada de forma segura
    \item[rkxwp]si la torre negra es mou a f7, amenaça al peó blanc
    \item[rxmsq]la torre negra pot atacar de forma segura la casella per fer escac i mat
    \item[simpl]hi aplica un patró molt simple perquè el peó blanc avança i corona (es converteix en una dama), aleshores la torre negra fa escac en a4 i, per tant, blanques estan forçades a menjar la torre amb la dama blanca 
    \item[skach]es pot fer 1 o més escacs al rei blanc per sacrificar el peó
    \item[skewr]hi ha una clavada potencial fent un atac doble: el peó blanc es corona i la torre negra mou a a4
    \item[skrxp]la torre negra pot aconseguir un atac doble o el rei negre pot atacar el peó blanc
    \item[spcop]hi ha una oposició especial entre dos reis
    \item[stlmt]el rei blanc és ofegat, és a dir: no té jugades legals per realitzar i el rei no es troba en estat d'escac. La partida acaba en taules
    \item[thrsk]fer escac a la descoberta (una peça qu eestà interferint l'acció d'una segona, s'aparta del seu camí) fent un doble atac
    \item[wkcti]el rei blanc no pot controlar el punt d'intersecció f4
    \item[wkna8]el rei blanc està a la casella a8
    \item[wknck]el rei blanc està en escac
    \item[wkovl]el rei blanc està sobrecarregat, és a dir: el rei blanc pot defensar una de les dues peces que estan sent amenaçades, per tant, sacrifica l'altre peça
    \item[wkpos]el rei blanc està en una potencial posició de rebre un atac doble
    \item[wtoeg]el rei blanc està a una casella de la cantonada
    \item[target] blanques guanyen (\textit{win}) o blanques perden (\textit{nowin})
\end{description}

La distribució que pren la variable classe \textsc{win} està equilibrada, és a dir: en 1669 posicions (52\%) les blanques guanyen, mentre que en 1527 posiicions (48\%) les blanques no guanyen.




%%%%%%%%%%%%%%%
%%%
%%% Subsection: Software
%%%
%%%%%%%%%%%%%%%
\subsection{Software}
Els paquets que s'utilitzaran són els següents:

<<echo=TRUE>>=
<<packages>>
@


%%%%%%%%%%%%%%%
%%%
%%% Section: Construcció d'un classificador Bayesià
%%%
%%%%%%%%%%%%%%%
\section{Construcció d'un classificador Bayesià}
\label{sec:bayesian}



%%%%%%%%%%%%%%%
%%%
%%% Subsection: Preprocessament de les dades
%%%
%%%%%%%%%%%%%%%
\subsection{Preprocessament de les dades}
\label{sec:preprocessing}

En primer lloc, carreguem les dades al directori on es treballa, ens assegurem que no hi hagi cap valor missing amb la funció \texttt{anyNA}, assignem totes les variables com a categòriques amb la funció \texttt{factor} i mirem un resum descriptiu de cadascuna de les variables.

<<data, results="hide", message=FALSE>>=
setwd("~/Trabajos del cole/ESTADÍSTICA APLICADA/4t curs/2n semestre/Modelització de Dades Complexes/Treball/chess/data")
#### Importar les dades: ####
dades <- read_csv("kr-vs-kp.data",
                  col_names = c("bkblk","bknwy","bkon8","bkona","bkspr",
                                "bkxbq","bkxcr","bkxwp","blxwp","bxqsq",
                                "cntxt","dsopp","dwipd","hdchk","katri",
                                "mulch","qxmsq","r2ar8","reskd","reskr",
                                "rimmx","rkxwp","rxmsq","simpl","skach",
                                "skewr","skrxp","spcop","stlmt","thrsk",
                                "wkcti","wkna8","wknck","wkovl","wkpos",
                                "wtoeg", "target"))

anyNA(dades)

# Passar a factor totes les variables
dades <- lapply(dades, factor) %>%
  as.data.frame()

str(dades)
apply(dades, 2, table)
@

Pel que fa al preprocessament de les dades, primerament hi ajustem un model de regressió logística amb la funció \texttt{glm} (veure Taula \ref{tab:glm}), ja que les la variable classe del dataset és dicotòmica (0-blanques perden, 1-blanques guanyen). 

\begin{table}
	\centering
<<preprocessing, results="asis">>=
#### Preprocessing de les dades: ####
model <- glm(target ~ ., data = dades, family = "binomial")
xtable(model)
@
	\caption{Model de regressió logística ajustat amb \texttt{glm}}
	\label{tab:glm}
\end{table}

A continuació, per seleccionar les variables estadísticament significatives realitzem una selecció per mitjà del Criteri d'Informació d'Akaike (AIC) amb l'\textit{Stepwise Algorithm}, tant el \textit{Forward} com el \textit{Backward}, i guardem el nou model amb les variables escollides en un nou objecte. El millor model escollit després de fer el mètode \textit{Stepwise} segons valor del AIC exlou les variables \textbf{stlmt, reskd, skewr, bkspr, simpl, wtoeg, dwipd} i \textbf{spcop}.

<<preprocessing2, results="hide">>=
stepwise <- stepAIC(model, direction = "both")
# el millor model escollit després de fer el mètode Stepwise segons valor del AIC
# treu les variables: stlmt, reskd, skewr, bkspr, simpl, wtoeg, dwipd, spcop

# Les variables escollides les guardem en aquest nou objecte:
dades.step <- stepwise$model
@


%%%%%%%%%%%%%%%
%%%
%%% Subsection: Naive Bayes classifier
%%%
%%%%%%%%%%%%%%%
\subsection{\textit{Naive Bayes classifier}}
\label{sec:naivebayes}


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge d'estructura
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge d'estructura}
\label{sec:structure}

Ara que ja hem fet el preprocessament de les dades, hem d'aprendre l'estructura de la xarxa mitjançant el mètode heurístic de \textit{Search-and-score}. Aquest mètode utilitza una funció de puntuació i l'algoritme intenta trobar l'estructura que la maximitzi, per això farem servir la funció \texttt{hc} de la llibreria \textbf{\texttt{bnlearn}}. En aquest cas, el nostre dataset conté només dades completes, com bé hem dit abans. 

Com volem que el classificador bayesià sigui un Naive Bayes, introduïrem una \textit{white list} perquè ens interessa que els arcs vagin des de la variable classe (\textbf{target}) cap a tota la resta de variables explicatives, i una \textit{black list} per evitar que les variables explicatives tinguin fletxes entre elles. 

<<structure, results='hide'>>=
#### 1er: Aprendre l'estructura de les dades (amb totes les variables) ####

# - Introduim la black i white list:
atributes <- colnames(dades[-ncol(dades)])
  
wl <- data.frame(from = rep("target", length(atributes)), to = atributes)
bl <- rbind(
  expand.grid(atributes, atributes),
  data.frame(Var1 = atributes, Var2= rep("target", length(atributes))),
  data.frame(Var1 = "target", Var2= "target")
)

# - Fem el k-fold cross validation:
kfold <- function(k, seed = NULL){
  if(!is.null(seed)) set.seed(seed)
  trainingset <- list()
  testset <- list()
  
  for(i in 1:k){
    dades$id <- sample(1:k, nrow(dades), replace = TRUE)
    folds <- 1:k
  
    trainingset[[i]] <- subset(dades, id %in% folds[-i])
    testset[[i]] <- subset(dades, id %in% c(i))
  }
  
  return(list(training = trainingset, test = testset))
}

# Generem la llista amb tots els folds i treiem la columna dels id's
# tant pels trainings com pels tests

training <- kfold(5, 666)$training %>%
  lapply(function(x) x[,-ncol(x)])

test <- kfold(5, 666)$test %>%
  lapply(function(x) x[,-ncol(x)])


# - Aprendre l'estructura de les dades per tots els possibles folds
xarxa <- lapply(training, function(x) hc(x, score = "bic", whitelist = wl, blacklist = bl))

# Fem el plot per cada fold
lapply(xarxa, graphviz.plot)
@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge de paràmetres
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge de paràmetres}
\label{sec:parameters}

Ara que ja tenim l'estructura de les dades donada, estimarem els paràmetres mitjançant la base de dades per a cadascuna de les variables. 

<<parameters, results='hide'>>=
#### 2on: Estimem els paràmetres de la xarxa, pel mètode MLE ####
xarxa.estimada <- list()
for(i in 1:5)
  xarxa.estimada[[i]] <- bn.fit(xarxa[[i]], training [[i]], method = "mle")

#### 3er: Fem la validació, estimar la classe per tots els conjunts tests ####
# passem la xarxa a format gRain
xarxa.grain <- lapply(xarxa.estimada, function(x) suppressWarnings(as.grain(x)))

distribucio <- NULL
prediccio <- NULL
CL <- NULL

for(i in 1:5){
  distribucio[[i]] <- list()
  prediccio[[i]] <- list()
  CL[[i]] <- list()
  for(j in 1:nrow(test[[i]])){
    if(is.numeric(predict(xarxa.grain[[i]], 
                          response="target", 
                          test[[i]][j,], 
                          predictors=atributes, 
                          type="dist")$pred[[1]][1,1])==FALSE)
    {
      prediccio[[i]][[j]]<-NA
      CL[[i]][[j]]<-0
      distribucio[[i]][[j]]<-c(rep(0,2))
    }
    else
    {
      distribucio[[i]][[j]] <- list(predict(xarxa.grain[[i]],
                                            response="target",
                                            test[[i]][j,],
                                            predictors=atributes,
                                            type="dist")$pred[[1]][1,])
      prediccio[[i]][[j]] <- names(distribucio[[i]][[j]][[1]])[which.max(distribucio[[i]][[j]][[1]])]
      CL[[i]][[j]]<-max(distribucio[[i]][[j]][[1]])
    }
  }
}
@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Classificació Bayesiana
%%%
%%%%%%%%%%%%%%%
\subsubsection{Classificació Bayesiana}
\label{sec:classification}

L'últim pas és fer la nostra Xarxa Bayesiana sigui un classificador bayesià per a que assigni a nous finals determinats de partides d'escacs si les peces blanques guanyaran o no. Ara que ja tenim l'estructura i l'estimació dels paràmetres podem avaluar la bondat d'ajust del model, és a dir: com s'adapta a les dades observades.

<<classification, results="hide">>=
#### 4t: Càlcul de la matriu de confusió i les mesures d'avaluació ####
matriu.confusio <- list()
for(i in 1:5)
  matriu.confusio[[i]] <- as.matrix(table(unlist(prediccio[[i]]), test[[i]]$target))

# Accuracy
accuracy_NB <- lapply(matriu.confusio, function(x) round((sum(x[1,1] + x[2,2])/sum(x))*100,2))
accuracy_NB <- unlist(accuracy_NB)

# True Positive Rate
TPR_NB <- lapply(matriu.confusio, function(x) round((sum(x[1,1])/sum(x[1,1] + x[2,1]))*100,2))
TPR_NB <- unlist(TPR_NB)

# True Negative Rate
TNR_NB <- lapply(matriu.confusio, function(x) round((sum(x[2,2])/sum(x[2,2] + x[1,2]))*100,2))
TNR_NB <- unlist(TNR_NB)

# Balanced Accuracy
baccuracy_NB <- (TPR_NB+TNR_NB)/2

# Positive Predictive Value
PPV_NB <- lapply(matriu.confusio, function(x) round((sum(x[1,1])/sum(x[1,1] + x[1,2]))*100,2))
PPV_NB <- unlist(PPV_NB)

# F1 score
F1_NB <- 2*((PPV_NB*TPR_NB)/(PPV_NB+TPR_NB))

@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Validació del model
%%%
%%%%%%%%%%%%%%%
\subsubsection{Validació del model}
\label{sec:validation}










%%%%%%%%%%%%%%%
%%%
%%% Subsection: Augmented Naive Bayes classifier
%%%
%%%%%%%%%%%%%%%
\subsection{\textit{Augmented Naive Bayes classifier}}
\label{sec:augmented_naivebayes}


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge d'estructura
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge d'estructura}
\label{sec:augmented_structure}

Volem que el classificador bayesià sigui un Augmented Naive Bayes, per fer aixó introduïrem una \textit{white list} perquè ens interessa que els arcs vagin des de la variable classe (\textbf{target}) cap a tota la resta de variables explicatives, però en aquest cas no afegirem una \textit{black list} perquè no ens cal evitar que les variables explicatives tinguin fletxes entre elles. 

<<augmented_structure, results='hide'>>=
#### 1er: Aprendre l'estructura de les dades (amb totes les variables) ####

# - Introduim la white list:
atributes <- colnames(dades[-ncol(dades)])
  
wl <- data.frame(from = rep("target", length(atributes)), to = atributes)

# - Fem el k-fold cross validation:
kfold <- function(k, seed = NULL){
  if(!is.null(seed)) set.seed(seed)
  trainingset <- list()
  testset <- list()
  
  for(i in 1:k){
    dades$id <- sample(1:k, nrow(dades), replace = TRUE)
    folds <- 1:k
  
    trainingset[[i]] <- subset(dades, id %in% folds[-i])
    testset[[i]] <- subset(dades, id %in% c(i))
  }
  
  return(list(training = trainingset, test = testset))
}

# Generem la llista amb tots els folds i treiem la columna dels id's
# tant pels trainings com pels tests

training <- kfold(5, 666)$training %>%
  lapply(function(x) x[,-ncol(x)])

test <- kfold(5, 666)$test %>%
  lapply(function(x) x[,-ncol(x)])


# - Aprendre l'estructura de les dades per tots els possibles folds
xarxa <- lapply(training, function(x) hc(x, score = "bic", whitelist = wl))

# Fem el plot per cada fold
lapply(xarxa, graphviz.plot)
@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge de paràmetres
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge de paràmetres}
\label{sec:augmented_parameters}

Ara que ja tenim l'estructura de les dades donada, estimarem els paràmetres mitjançant la base de dades per a cadascuna de les variables. 

<<augmented_parameters, results='hide'>>=
#### 2on: Estimem els paràmetres de la xarxa, pel mètode MLE ####
xarxa.estimada <- list()
for(i in 1:5)
  xarxa.estimada[[i]] <- bn.fit(xarxa[[i]], training [[i]], method = "mle")

#### 3er: Fem la validació, estimar la classe per tots els conjunts tests ####
# passem la xarxa a format gRain
xarxa.grain <- lapply(xarxa.estimada, function(x) suppressWarnings(as.grain(x)))

distribucio <- NULL
prediccio <- NULL
CL <- NULL

for(i in 1:5){
  distribucio[[i]] <- list()
  prediccio[[i]] <- list()
  CL[[i]] <- list()
  for(j in 1:nrow(test[[i]])){
    if(is.numeric(predict(xarxa.grain[[i]], 
                          response="target", 
                          test[[i]][j,], 
                          predictors=atributes, 
                          type="dist")$pred[[1]][1,1])==FALSE)
    {
      prediccio[[i]][[j]]<-NA
      CL[[i]][[j]]<-0
      distribucio[[i]][[j]]<-c(rep(0,2))
    }
    else
    {
      distribucio[[i]][[j]] <- list(predict(xarxa.grain[[i]],
                                            response="target",
                                            test[[i]][j,],
                                            predictors=atributes,
                                            type="dist")$pred[[1]][1,])
      prediccio[[i]][[j]] <- names(distribucio[[i]][[j]][[1]])[which.max(distribucio[[i]][[j]][[1]])]
      CL[[i]][[j]]<-max(distribucio[[i]][[j]][[1]])
    }
  }
}
@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Classificació Bayesiana
%%%
%%%%%%%%%%%%%%%
\subsubsection{Classificació Bayesiana}
\label{sec:augmented_classification}

L'últim pas és fer la nostra Xarxa Bayesiana sigui un classificador bayesià per a que assigni a nous finals determinats de partides d'escacs si les peces blanques guanyaran o no. Ara que ja tenim l'estructura i l'estimació dels paràmetres podem avaluar la bondat d'ajust del model, és a dir: com s'adapta a les dades observades.

<<augmented_classification, results="hide">>=
#### 4t: Càlcul de la matriu de confusió i les mesures d'avaluació ####
matriu.confusio <- list()
for(i in 1:5)
  matriu.confusio[[i]] <- as.matrix(table(unlist(prediccio[[i]]), test[[i]]$target))

# Accuracy
accuracy_ANB <- lapply(matriu.confusio, function(x) round((sum(x[1,1] + x[2,2])/sum(x))*100,2))
accuracy_ANB <- unlist(accuracy_ANB)

# True Positive Rate
TPR_ANB <- lapply(matriu.confusio, function(x) round((sum(x[1,1])/sum(x[1,1] + x[2,1]))*100,2))
TPR_ANB <- unlist(TPR_ANB)

# True Negative Rate
TNR_ANB <- lapply(matriu.confusio, function(x) round((sum(x[2,2])/sum(x[2,2] + x[1,2]))*100,2))
TNR_ANB <- unlist(TNR_ANB)

# Balanced Accuracy
baccuracy_ANB <- (TPR_ANB+TNR_ANB)/2

# Positive Predictive Value
PPV_ANB <- lapply(matriu.confusio, function(x) round((sum(x[1,1])/sum(x[1,1] + x[1,2]))*100,2))
PPV_ANB <- unlist(PPV_ANB)

# F1 score
F1_ANB <- 2*((PPV_ANB*TPR_ANB)/(PPV_ANB+TPR_ANB))

@


%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Validació del model
%%%
%%%%%%%%%%%%%%%
\subsubsection{Validació del model}
\label{sec:augmented_validation}



%%%%%%%%%%%%%%%
%%%
%%% Subsection: Triatge del clasificador bayesiá final
%%%
%%%%%%%%%%%%%%%
\subsection{\textit{Triatge del calsificador bayesiá final}}
\label{sec:triatge_clasificador}

Una vegada ja tenim el dos clasificador bayesians "Naive Bayes" i "Augmented Naive Bayes" hem de triar quina de les dues xarxes modelitza millor les nostres dades d'escacs, i aixó o podem fer a partir de les mesures de bondat d'ajust de cadascuna de les xarxes.

<<triatge, results="hide">>=
Accuracy <- rbind(accuracy_NB,accuracy_ANB)
colnames(Accuracy) <- paste0(1:5,"-fold")
Accuracy

TPR <- rbind(TPR_NB,TPR_ANB)
colnames(TPR) <- paste0(1:5,"-fold")
TPR

TNR <- rbind(TNR_NB,TNR_ANB)
colnames(TNR) <- paste0(1:5,"-fold")
TNR

PPV <- rbind(PPV_NB,PPV_ANB)
colnames(PPV) <- paste0(1:5,"-fold")
PPV

F1 <- rbind(F1_NB, F1_ANB)
colnames(F1) <- paste(1:5, "-fold")
F1

(Accuracy <- apply(Accuracy, 1, FUN=mean))
(TPR <- apply(TPR, 1, FUN=mean))
(TNR <- apply(TNR, 1, FUN=mean))
(PPV <- apply(PPV, 1, FUN=mean))
#Hacer tabla con las mesures.
@


Veiem que totes les mesures (accuracy, TPR, TNR, PPV, F1) que hem calculat per saber com de bé estima les xarxes bayesianes, les del "Augmented Naive Bayes" són més elevades (>95 \%) que les del "Naive Bayes" y per tant triem el model de Augmented Naive Bayes per modelar de nou pero ara amb tota la base de dades training sense fer k-fold ja que ara farem servir split-validation per poder validar el model, dividim la base de dades, a l'atzar, en dos trossos, training (80\%), amb el qual aprendrem la xarxa, i validate (20\%).

%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge d'estructura final
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge d'estructura final}
\label{sec:augmented_structure_final}

Com finalment la xarxa ha de ser un Augmented Naive Bayes, tornarem ha generar una \textit{white list} per forçar tot els arcs de la variable clase (\textbf{target}) p a la resta de variables, pero sense una \textit{black list} per que el model pugui crear arcs entre les variables explicatives.

<<final_structure, results="hide">>=
atributes <- colnames(dades[-ncol(dades)])

wl <- data.frame(from = rep("target", length(atributes)), to = atributes)

splitdf <- function(dataframe, seed = NULL){
  if(!is.null(seed)) set.seed(seed)
  index <- 1:nrow(dataframe)
  trainingindex <- sample(index,length(index)*0.8)
  trainingset <- dataframe[trainingindex, ]
  validateset <- dataframe[-trainingindex, ]
  list(trainingset = trainingset, validateset = validateset)
}

splits <- splitdf(dades, seed = 666)
# ens dona una llista: dos data frames anomenats "training" i "validate"
# Nombre d'observacions en cada subconjunt de dades:
lapply(splits, nrow)

xarxa <- hc(splits$trainingset, score = "bic", whitelist = wl)
@

%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Aprenentatge de paràmetres finals
%%%
%%%%%%%%%%%%%%%
\subsubsection{Aprenentatge de paràmetres finals}
\label{sec:augmented_parameters_final}

Ara que ja tenim l'estructura de les dades donada, estimarem els paràmetres mitjançant la base de dades per a cadascuna de les variables. 

<<final_parameters, results="hide">>=
xarxa.estimada <- bn.fit(xarxa, splits$trainingset, method = "mle")
xarxa.grain <- suppressWarnings(as.grain(xarxa.estimada))

prediccio <- NULL
CL <- NULL
prueba <- NULL
distribucio <- NULL

for (j in 1:nrow(splits$validateset)){
  if (is.numeric(predict(xarxa.grain, response="target", 
                         splits$validateset[j,], predictors = atributes,
                         type = "dist")$pred[[1]][1,1])==FALSE){
    prediccio[[j]] <- NA
    CL[[j]] <- 0
    distribucio[[j]] <- c(rep(0,2))
  }
  else{
    prueba[[j]] <- predict(xarxa.grain, response="target", 
                           splits$validateset[j,], predictors = atributes, 
                           type="dist")
    distribucio[[j]] <- prueba[[j]]$pred[[1]]
    prediccio[[j]] <- dimnames(distribucio[[j]])[[2]][which.max(distribucio[[j]])]
    CL[[j]] <- max(distribucio[[j]])
  }
}
@

%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Classificació Bayesiana final
%%%
%%%%%%%%%%%%%%%
\subsubsection{Classificació Bayesiana final}
\label{sec:final_classification}

L'últim pas és fer la nostra Xarxa Bayesiana sigui un classificador bayesià per a que assigni a nous finals determinats de partides d'escacs si les peces blanques guanyaran o no. Ara que ja tenim l'estructura i l'estimació dels paràmetres podem avaluar la bondat d'ajust del model, és a dir: com s'adapta a les dades observades.

<<final_classification, results="hide">>=
matriu.confusio <- as.matrix(table(prediccio, splits$validateset$target))
matriu.confusio

# Accuracy
Accuracy_final <- round((sum(matriu.confusio[1,1] + 
                               matriu.confusio[2,2])/
                                  sum(matriu.confusio))*100,2)

# True Positive Rate
TPR_final <- round((sum(matriu.confusio[1,1])/
                      sum(matriu.confusio[1,1] + 
                            matriu.confusio[2,1]))*100,2)

# True Negative Rate
TNR_final <- round((sum(matriu.confusio[2,2])/
                      sum(matriu.confusio[2,2] + 
                            matriu.confusio[1,2]))*100,2)

# Balanced Accuracy
baccuracy_final <- round((TPR_final+TNR_final)/2,2)

# Positive Predictive Value
PPV_final <- round((sum(matriu.confusio[1,1])/
                      sum(matriu.confusio[1,1] + 
                            matriu.confusio[1,2]))*100,2)

# F1 score
F1_final <- round(2*((PPV_final*TPR_final)/(PPV_final+TPR_final)),2)

Mesures <- rbind(Accuracy_final, TPR_final, TNR_final, 
                 baccuracy_final, PPV_final, F1_final)
rownames(Mesures) <- c("Accuracy","True Positive Rate", 
                       "True Negative Rate", "Balanced Accuracy", 
                       "Positive Predictive Value", "F1 score")
colnames(Mesures) <- "Métriques"
Mesures

# Observem finalment que la xarxa bayesiana Augmented Naive Bayes obté unes 
# métriques molt bones (>94%) 
@

%%%%%%%%%%%%%%%
%%%
%%% Subsubsection: Validació del model
%%%
%%%%%%%%%%%%%%%
\subsubsection{Validació del model}
\label{sec:final_validation}




%%%%%%%%%%%%%%%
%%%
%%% Section: Predicció per noves partides
%%%
%%%%%%%%%%%%%%%
\section{Predicció per noves partides}
\label{sec:prediccions}

Ara podem simular noves partides d'escacs on es doni aquesta situació de final de partida onles peces blanques tenen el Rei i un Peó mentres que les negres tenen el Rei i un torre.

\begin{figure}[ht!]
     \begin{center}
<<new_game, results="hide">>=
# https://www.apronus.com/chess/diagram/editor/
chss3 <- Chess$new("8/P7/8/2k5/2r5/8/K7/8 w - - 0 1")
plot(chss3)
@
     \caption{Diagrama d'escacs. Torre i rei negres contra rei i peó blancs.}
     \label{fig:chss3}
     \end{center}
\end{figure}

<<predictions, results="hide">>=
a <- lapply(dades, function(x) sample(levels(x),1))
a <- unlist(a[-c(length(a))])

a <- dades[sample(1:nrow(dades),1),]
a <- a[-c(length(a))]

a <- c(TRUE,FALSE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,
       "g",FALSE,"n",TRUE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,TRUE,TRUE,
       TRUE,TRUE,FALSE,FALSE,TRUE,TRUE,FALSE,FALSE,TRUE,TRUE,"n")

xarxa.evid <- setEvidence(xarxa.grain, nodes = atributes,
                          states = a)
evid <- xarxa.evid$evidence
qq <- querygrain(xarxa.evid, nodes = c("target"), type = "marginal")
distribucio <- qq$target
prediccio <- dimnames(distribucio)[[1]][which.max(distribucio)]
CL <- round(100*max(distribucio), 2)
reincidence.risc <- round(100*distribucio[2], 2)

Resultat <- matrix(c(prediccio, CL,reincidence.risc),nrow=1)
Resultat <- as.data.frame(Resultat)
colnames(Resultat) <- c("Predicció","Confidence Level (CL) en %",
                        "Risc de reincidència")
evid
Resultat
@



%%%%%%%%%%%%%%%
%%%
%%% References
%%%
%%%%%%%%%%%%%%%
\begin{thebibliography}{99}
   \bibitem{rchess} rchess \textit{A Chess package for \R.} \url{http://jkunst.com/rchess/} [Online; visitat el 27 de març de 2021]
   \bibitem{chess} chess \textit{Definition of chess.} \url{https://www.merriam-webster.com/dictionary/chess} [Online; visitat el 27 de març de 2021]
   \bibitem{enciclopedia} escacs \textit{Escacs} \url{https://www.enciclopedia.cat/ec-gec-0153105.xml} [Online; visitat el 27 de març de 2021]
   \bibitem{fases} \textit{Fases de la partida.} \url{https://www.123ajedrez.com/la-partida-de-ajedrez/fases-de-la-partida} [Online; visitat el 27 de març de 2021]
   \bibitem{final} Final (escacs) \textit{Finals contra rei i peó.} \url{https://ca.wikipedia.org/wiki/Final_(escacs)} [Online; visitat el 27 de març de 2021]
    \bibitem{escacs} Escacs \textit{L'escaquer.} \url{https://ca.wikipedia.org/wiki/Escacs} [Online; visitat el 27 de març de 2021]
    \bibitem{database} Base de dades \textit{Chess (King-Rook vs. King-Pawn) Data Set.} \url{https://archive.ics.uci.edu/ml/datasets/Chess+\%28King-Rook+vs.+King-Pawn\%29} [Online; visitat el 27 de març de 2021]
\end{thebibliography} 


%%%%%%%%%%%%%%%
%%%
%%% Appendix
%%%
%%%%%%%%%%%%%%%
\clearpage
\appendix
\section{\R code}
\label{app:Rcode}

\subsection{Preprocessament de les dades}

<<echo=TRUE, eval=FALSE>>=
<<data>>
<<preprocessing>>
<<preprocessing2>>
@

\subsection{\textit{Naive Bayes classifier}}

<<echo=TRUE, eval=FALSE>>=
<<structure>>
<<parameters>>
<<classification>>
@

\subsection{\textit{Augmented Naive Bayes classifier}}

<<echo=TRUE, eval=FALSE>>=
<<augmented_structure>>
<<augmented_parameters>>
<<augmented_classification>>
@

\subsection{\textit{Triatge del clasificador bayesiá final}}

<<echo=TRUE, eval=FALSE>>=
<<triatge>>
<<final_structure>>
<<final_parameters>>
<<final_classification>>
@

\subsection{\textit{Predicció per noves partides}}

<<echo=TRUE, eval=FALSE>>=
<<predictions>>
@



\end{document}
